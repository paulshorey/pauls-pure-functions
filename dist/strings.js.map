{"version":3,"sources":["strings.js"],"names":["matrix_flatten_to_strings","matrix","length","result","allCasesOfRest","slice","i","j","push","strings_shuffle_last_strict","strs","output","prev_ll","prev_strs_length","str","ll","splice","Set","strings_shuffle_first_last_strict","prev_fl","fl","strings_shuffle_last","input_strs","memory_strs","unique_strs","loops","old_strs","infinite_loop","new_strs","unique_str","unique_str_ll","unique_str2","unique_str2_ll","str_ll","shift","strings_shuffle_first_last","unique_str_fl","unique_str2_fl","str_fl","strings_shuffle_last3_strict","strings_shuffle_first_last_loose","unique_str3","unique_str3_fl","unique_str3_ll","strings_shuffle_last3","strings_shuffle_first3","strings_shuffle_first2"],"mappings":"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","file":"strings.js","sourceRoot":"../src","sourcesContent":["/**\n * Flatten a matrix of strings -\n *    - generate list of all unique possible cases, from matrix of strings\n * @params matrix {array} - array of arrays of strings, in a matrix format\n * @returns {array} - array of arrays of strings -\n *    - no longer a matrix, but just lists of phrases (phrase = array of strings)\n */\n// export const matrix_flatten_to_arrays = function (matrix) {\n//   if (matrix.length === 1) {\n//     return matrix[0]\n//   } else {\n//     let result = []\n//     let allCasesOfRest = matrix_flatten_to_arrays(matrix.slice(1)) // recur with the rest of matrixay\n//     for (let i = 0; i < allCasesOfRest.length; i++) {\n//       for (let j = 0; j < matrix[0].length; j++) {\n//         result.push(matrix[0][j] + allCasesOfRest[i])\n//       }\n//     }\n//     return result\n//   }\n// }\n/**\n * Flatten a matrix of strings -\n *    - generate list of all unique possible cases, from matrix of strings\n * @params matrix {array} - array of arrays of strings, in a matrix format\n * @returns {array} - array of combined strings, separated by space\n */\nexport const matrix_flatten_to_strings = function (matrix) {\n  if (!matrix.length) {\n    return []\n  } else if (matrix.length === 1) {\n    return matrix[0]\n  } else {\n    let result = []\n    let allCasesOfRest = matrix_flatten_to_strings(matrix.slice(1)) // recur with the rest of matrixay\n    for (let i = 0; i < allCasesOfRest.length; i++) {\n      for (let j = 0; j < matrix[0].length; j++) {\n        result.push(matrix[0][j] + \" \" + allCasesOfRest[i])\n      }\n    }\n    return result\n  }\n}\n\n/**\n * Shuffle some strings\n *    do not allow two strings to repeat which have the same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const strings_shuffle_last_strict = function (strs) {\n  let output = []\n  let prev_ll = \"\" // last letter\n  let prev_strs_length = 0\n\n  // while loop as long as it takes! (should only be for a few milliseconds)\n  while (true) {\n    // prevent infinite loop - if strs arr length has not been changed,\n    // then we've reached a stalemate - no new items will be used\n    if (strs.length === prev_strs_length) {\n      break\n    } else {\n      prev_strs_length = strs.length\n    }\n    // each while loop, we'll take items out of the strs arr\n    for (let i = 0; i < strs.length; i++) {\n      // examine current item\n      let str = strs[i]\n      let ll = str[str.length - 1]\n      // if current string starts with different letter than previous string,\n      // add it to output. Else, ignore it, to examine it again next iteration\n      if (prev_ll !== ll) {\n        // add current item to output arr\n        output.push(str)\n        prev_ll = ll\n        // remove current item from input arr\n        strs.splice(i, 1)\n        i--\n      }\n    }\n  }\n\n  return [...new Set([...output, ...strs])]\n}\n\n/**\n * Shuffle some strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const strings_shuffle_first_last_strict = function (strs) {\n  let output = []\n  let prev_fl = \"\" // first letter\n  let prev_ll = \"\" // last letter\n  let prev_strs_length = 0\n\n  // while loop as long as it takes! (should only be for a few milliseconds)\n  while (true) {\n    // prevent infinite loop - if strs arr length has not been changed,\n    // then we've reached a stalemate - no new items will be used\n    if (strs.length === prev_strs_length) {\n      break\n    } else {\n      prev_strs_length = strs.length\n    }\n    // each while loop, we'll take items out of the strs arr\n    for (let i = 0; i < strs.length; i++) {\n      // examine current item\n      let str = strs[i]\n      let fl = str[0]\n      let ll = str[str.length - 1]\n      // if current string starts with different letter than previous string,\n      // add it to output. Else, ignore it, to examine it again next iteration\n      if (prev_ll !== ll && prev_fl !== fl) {\n        // add current item to output arr\n        output.push(str)\n        prev_fl = fl\n        prev_ll = ll\n        // remove current item from input arr\n        strs.splice(i, 1)\n        i--\n      }\n    }\n  }\n\n  return [...new Set([...output, ...strs])]\n}\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const strings_shuffle_last = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_ll = unique_str[unique_str.length - 1] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_ll = str[str.length - 1]\n        if (str_ll === unique_str_ll && str_ll === unique_str2_ll) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_ll = str[str.length - 1]\n      if (str_ll === unique_str_ll && str_ll === unique_str2_ll) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const strings_shuffle_first_last = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_fl = unique_str[0] || \"\"\n    let unique_str_ll = unique_str[unique_str.length - 1] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_fl = unique_str2[0] || \"\"\n    let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_fl = str[0]\n        let str_ll = str[str.length - 1]\n        if (\n          (str_fl === unique_str_fl && str_fl === unique_str2_fl) ||\n          (str_ll === unique_str_ll && str_ll === unique_str2_ll)\n        ) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_fl = str[0]\n      let str_ll = str[str.length - 1]\n      if (\n        (str_fl === unique_str_fl && str_fl === unique_str2_fl) ||\n        (str_ll === unique_str_ll && str_ll === unique_str2_ll)\n      ) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n/**\n * Shuffle some strings\n *    do not allow two strings to repeat which have the same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const strings_shuffle_last3_strict = function (strs) {\n  let output = []\n  let prev_ll = \"\" // last letter\n  let prev_strs_length = 0\n\n  // while loop as long as it takes! (should only be for a few milliseconds)\n  while (true) {\n    // prevent infinite loop - if strs arr length has not been changed,\n    // then we've reached a stalemate - no new items will be used\n    if (strs.length === prev_strs_length) {\n      break\n    } else {\n      prev_strs_length = strs.length\n    }\n    // each while loop, we'll take items out of the strs arr\n    for (let i = 0; i < strs.length; i++) {\n      // examine current item\n      let str = strs[i]\n      let ll = str[str.length - 3] + str[str.length - 2] + str[str.length - 1]\n      // if current string starts with different letter than previous string,\n      // add it to output. Else, ignore it, to examine it again next iteration\n      if (prev_ll !== ll) {\n        // add current item to output arr\n        output.push(str)\n        prev_ll = ll\n        // remove current item from input arr\n        strs.splice(i, 1)\n        i--\n      }\n    }\n  }\n\n  return [...new Set([...output, ...strs])]\n}\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const strings_shuffle_first_last_loose = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_fl = unique_str[0] || \"\"\n    let unique_str_ll = unique_str[unique_str.length - 1] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_fl = unique_str2[0] || \"\"\n    let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\"\n\n    let unique_str3 = unique_strs[unique_strs.length - 3] || \"\" // 2nd to last added\n    let unique_str3_fl = unique_str3[0] || \"\"\n    let unique_str3_ll = unique_str3[unique_str3.length - 1] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_fl = str[0]\n        let str_ll = str[str.length - 1]\n        if (\n          (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) ||\n          (str_ll === unique_str_ll && str_ll === unique_str2_ll && str_ll === unique_str3_ll)\n        ) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_fl = str[0]\n      let str_ll = str[str.length - 1]\n      if (\n        (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) ||\n        (str_ll === unique_str_ll && str_ll === unique_str2_ll && str_ll === unique_str3_ll)\n      ) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const strings_shuffle_last3 = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_ll = unique_str[unique_str.length - 1] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_ll = str[str.length - 1]\n        if (str_ll === unique_str_ll && str_ll === unique_str2_ll) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_ll = str[str.length - 1]\n      if (str_ll === unique_str_ll && str_ll === unique_str2_ll) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const strings_shuffle_first3 = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_fl = unique_str[0] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_fl = unique_str2[0] || \"\"\n\n    let unique_str3 = unique_strs[unique_strs.length - 3] || \"\" // 3rd to last added\n    let unique_str3_fl = unique_str3[0] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_fl = str[0]\n        if (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_fl = str[0]\n      if (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n  // console.log(\"unique_strs\", unique_strs)\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const strings_shuffle_first2 = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_fl = unique_str[0] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_fl = unique_str2[0] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_fl = str[0]\n        if (str_fl === unique_str_fl && str_fl === unique_str2_fl) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_fl = str[0]\n      if (str_fl === unique_str_fl && str_fl === unique_str2_fl) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n  // console.log(\"unique_strs\", unique_strs)\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n//\n// export const strings_shuffle = function(input_strs, {first=false, last=false, repeat=3, chars=1}) {\n//\n//   let memory_strs = []\n//   let unique_strs = []\n//\n//   // console.time(\"1000 loops\")\n//   let loops = 0\n//   let old_strs = \"\"\n//   infinite_loop: while (loops < 1000) {\n//     loops++\n//\n//     // don't waste time on the same value\n//     let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n//     if (new_strs === old_strs) {\n//       break infinite_loop\n//     }\n//     old_strs = new_strs\n//\n//     // no more inputs\n//     if (!input_strs.length && !memory_strs.length) {\n//       break infinite_loop\n//     }\n//\n//     // first time\n//     if (!unique_strs.length) {\n//       unique_strs.push(input_strs.shift())\n//       continue infinite_loop\n//     }\n//\n//     // last string\n//     let unique_str = unique_strs[unique_strs.length - 1] || \"\"\n//     let unique_str_fl = unique_str[0] || \"\"\n//     let unique_str_ll = unique_str[unique_str.length - 1] || \"\" // last character\n//     // 2nd last string\n//     let unique_str2 = unique_strs[unique_strs.length - 2] || \"\"\n//     let unique_str2_fl = unique_str2[0] || \"\"\n//     let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\" // last character\n//     // 3rd last string\n//     let unique_str3 = unique_strs[unique_strs.length - 3] || \"\"\n//     let unique_str3_fl = unique_str3[0] || \"\"\n//     let unique_str3_ll = unique_str3[unique_str3.length - 1] || \"\" // last character\n//\n//     // insert new str\n//     // from memory\n//     if (memory_strs.length) {\n//       for (let str of memory_strs) {\n//         if (!str) continue\n//         let str_fl = str[0]\n//         let str_ll = str[str.length - 1]\n//         if (\n//           (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) ||\n//           (str_ll === unique_str_ll && str_ll === unique_str2_ll && str_ll === unique_str3_ll)\n//         ) {\n//           // not unique\n//           continue\n//         } else {\n//           // add unique\n//           unique_strs.push(memory_strs.shift())\n//           continue infinite_loop\n//         }\n//       }\n//     }\n//\n//     // insert new str\n//     // from input\n//     labeled_if:\n//     if (input_strs[0]) {\n//       let str = input_strs.shift()\n//       let str_fl = str[0]\n//       let str_ll = str[str.length - 1]\n//       if (\n//         (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) ||\n//         (str_ll === unique_str_ll && str_ll === unique_str2_ll && str_ll === unique_str3_ll)\n//       ) {\n//         // not unique\n//         memory_strs.push(str)\n//       } else {\n//         // add unique\n//         unique_strs.push(str)\n//       }\n//     }\n//   }\n//\n//   return [...unique_strs, ...memory_strs, ...input_strs]\n// }\n"]}