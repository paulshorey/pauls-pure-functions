{"mappings":"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","sources":["./src/asort_strings/asort_by_extension.js","./src/asort_strings/asort_by_length_asc.js","./src/asort_strings/asort_by_matches_in_list.js","./src/asort_strings/asort_by_rating.js","./src/asort_strings/asort_by_rating_and_position.js","./src/asort_strings/asort_by_length_and_position.js","./src/asort_objects/asort_by_property.js","./src/asort_objects/asort_by_property_and_position.js","./src/arrays.js","./src/asort_words.js","./src/astrings.js","./src/cli.js","./src/functions.js","./src/numbers.js","./src/objects.js","./src/promises.js","./src/req.js","./src/strings.js","./src/urls.js","./src/requests.js","./src/sh.js","./src/ui.js","./src/words.js","./src/index.js","./src/asort_strings/asort_strings_combine_lists.js"],"sourcesContent":["/**\n * Used to sort a list of domain names by their domain extension - putting best ones higher in list.\n * @param arr {Array<String>} - list of strings - each string must contain at least one period \".\"\n *      NOTE: this function modifies the original array, using .sort()!\n * @param endings {array} - list of endings (domain extensions) to sort by. Best = first. Worst = last.\n * @returns {array} - sorted array\n */\nexport default function asort_by_extension(arr, endings) {\n\treturn arr.sort(asort_by_extension__helper.bind(endings));\n};\n\nfunction asort_by_extension__helper(a, b) {\n\tlet a_score = this.indexOf(a.substr(a.indexOf('.') + 1));\n\tlet b_score = this.indexOf(b.substr(b.indexOf('.') + 1));\n\treturn a_score - b_score;\n}\n","/**\n * Sort array by string length, ascending (or descending with false flag)\n * @param arr {Array<String|Number|Array>}\n * @param desc {boolean} - if true, will sort descending; default is false, ascending\n * @returns {array}\n */\nexport default function asort_by_length_asc(arr, desc = false) {\n  if (desc) {\n    return arr.sort((a, b) => b.toString().length - a.toString().length)\n  } else {\n    return arr.sort((a, b) => a.toString().length - b.toString().length)\n  }\n};","/**\n * Sort strings by relevance (matching words in list)\n * Strings will be promoted if they match most words in list, and have fewest remaining characters.\n * @param arr {Array<String>} - list of strings\n *      (this function modifies the original array, using .sort())\n * @param matchList {array} - list of words -\n * @returns {array} - sorted array\n */\nexport default function asort_by_matches_in_list(arr, matchList) {\n\tlet ratings = {};\n\tfor (let str of arr) {\n\t\tlet string = str.replace(/[^a-z0-9]/gi, '');\n\t\tlet count = 0;\n\t\tfor (let word of matchList) {\n\t\t\tif (string.includes(word)) {\n\t\t\t\tcount++;\n\t\t\t\tstring = string.replace(word, '');\n\t\t\t}\n\t\t}\n\t\tratings[str] = count;\n\t}\n\treturn arr.sort(asort_by_matches_in_list__helper.bind(ratings));\n};\n\nfunction asort_by_matches_in_list__helper(a, b) {\n\tlet a_score = this[a] || 0;\n\tlet b_score = this[b] || 0;\n\treturn b_score - a_score;\n}","/**\n * Sort array of strings by separate dictionary of [{string:rating},]\n * However, will be sorted not in relation to other ratings, but in relation to zero 0.\n * If higher than 0, will be promoted. Lower than 0 will be demoted to back of list.\n * (Todo: File/Function should be renamed, to reflect this relation to zero!)\n * @param arr {Array.<String>} - array of strings\n * @param preferences {object} - dictionary of {string:rating}\n *      rating lt 0 == bad, gt 0 == good, if undefined, default 0\n * @return {Array.<String>} - array of strings\n */\nexport default function asort_strings_by_rating(arr, preferences) {\n  // compile ratings\n  let ratings = {}\n  for (let string of arr) {\n    // from dictionary of {string:rating}\n    // good == above zero; bad == below zero;\n    ratings[string] = preferences[string] || 0\n  }\n  return arr.sort(asort_strings_by_rating__helper.bind(ratings))\n};\n\n// helper function:\nfunction asort_strings_by_rating__helper(a, b) {\n  let a_rating = this[a]\n  let b_rating = this[b]\n  // prefer higher number\n  // if b is higher, then rate it better than a\n  return b_rating - a_rating\n}\n\n","/**\n * Sort array of strings by separate dictionary of [{string:rating},], and\n * also by position in array. Items at front of array will be rated higher.\n * @param arr {Array.<String>} - array of strings\n * @param ratings {object} - dictionary of {string:rating}\n *      ratings does not have to contain an entry for each arr item\n *          if missing, will be given default 0\n *      likewise, it may contain more entries than arr,\n *          extras will be ignored\n * @param multiply_position {number} - make position x times more important than rating\n * @return {Array.<String>} - array of strings\n */\nexport default function asort_strings_by_rating_and_position(\n  arr,\n  ratings,\n  multiply_position = 1\n) {\n  let that = {}\n\n  // ratings\n  that.min_rating = null\n  that.max_rating = null\n  that.ratings = ratings\n  for (let str in ratings) {\n    let rate = ratings[str]\n    // compare ratings to each other\n    if (that.min_rating === null || rate < that.min_rating) {\n      that.min_rating = rate\n    }\n    if (that.max_rating === null || rate > that.max_rating) {\n      that.max_rating = rate\n    }\n  }\n  that.delta_rating = that.max_rating - that.min_rating\n  that.median_rating = that.min_rating + that.delta_rating / 2\n\n  // prepare position indexes\n  that.min_index = 0\n  that.max_index = arr.length - 1\n  that.indexes = {}\n  for (let i in arr) {\n    // count up - first item = 0, last item = (length-1)\n    let string = arr[i]\n    that.indexes[string] = i\n  }\n  that.delta_index = that.max_index - that.min_index\n  that.multiply_position = multiply_position\n\n  // sort\n  return arr.sort(asort_strings_by_rating_and_position__helper.bind(that))\n}\n\n// helper function:\nfunction asort_strings_by_rating_and_position__helper(a, b) {\n  // higher == better\n  // normalized to 0-1 range\n  // highest rating gets 1, lowest rating gets 0\n  let a_rating =\n    (this.delta_rating -\n      (this.max_rating - (typeof this.ratings[a] !== \"undefined\" ? this.ratings[a] : this.median_rating))) /\n    this.delta_rating\n  let b_rating =\n    (this.delta_rating -\n      (this.max_rating - (typeof this.ratings[b] !== \"undefined\" ? this.ratings[b] : this.median_rating))) /\n    this.delta_rating\n\n  // higher == better\n  // normalized to 0-1 range\n  // lowest index gets 1, highest index gets 0\n  // (multiply_position to make position score more important than rating score)\n  let a_index = ((this.max_index - this.indexes[a]) / this.delta_index) * this.multiply_position\n  let b_index = ((this.max_index - this.indexes[b]) / this.delta_index) * this.multiply_position\n\n  // combine the two\n  // if b is higher, then sort it closer to front of array compared to a\n  return b_rating + b_index - (a_rating + a_index)\n}\n","import { asort_by_length_asc } from \"./index.js\"\n\n/**\n * Algorithm sort = by Length + by Position in array\n * @param arr {Array.<String>} - array of strings\n * @param prefer_position {number} - number to multiply position rating, to make it more important than length\n * @param fix_min_length {number} - absolute minimum allowed to be used as min_length (default 4)\n *      ex: if 4, algorithm will treat str.length of 2,3,4 the same\n * @return {Array.<String>} - array of strings\n */\nexport default function asort_by_length_and_position(arr, prefer_position = 10, fix_min_length = 0) {\n  if (!arr) return []\n  try {\n    // prepare ratings by length\n    let ascending = asort_by_length_asc([...arr])\n    if (!ascending[0]) {\n      return arr\n    }\n    // prepare ratings by position\n    let arr_positions = {}\n    for (let i in arr) {\n      let string = arr[i]\n      arr_positions[string] = i\n    }\n    // compile ratings\n    // ${this} in [].sort()\n    let that = {\n      min_length: ascending[0].length,\n      max_length: ascending[ascending.length - 1].length,\n      min_position: 0,\n      max_position: arr.length,\n      delta_position: arr.length,\n      arr_positions: arr_positions,\n      prefer_position: prefer_position,\n    }\n    // ${this} fix & finish\n    if (fix_min_length) {\n      that.fix_min_length = fix_min_length\n      that.min_length = fix_min_length\n    }\n    that.delta_length = that.max_length - that.min_length\n    // done\n    return arr.sort(asort_by_length_and_position_asc__helper.bind(that))\n  } catch (e) {\n    console.error('invalid input array to asort_by_length_and_position()')\n    return arr\n  }\n};\n\n// helper function:\nfunction asort_by_length_and_position_asc__helper(a, b) {\n  // if length is less than absolute minimum, use absolute minimum\n  let a_length = a.length\n  let b_length = b.length\n  if (this.fix_min_length) {\n    if (a.length < this.fix_min_length) a_length = this.fix_min_length\n    if (b.length < this.fix_min_length) b_length = this.fix_min_length\n  }\n  // lower number == good (prefer shorter words)\n  let a_rating_length = ((a_length - this.min_length) / this.delta_length)\n  let b_rating_length = ((b_length - this.min_length) / this.delta_length)\n  // lower number == good (lower index in array, so started closer to #1)\n  let a_position_length = ((this.arr_positions[a] - this.min_position) / this.delta_position) * this.prefer_position\n  let b_position_length = ((this.arr_positions[b] - this.min_position) / this.delta_position) * this.prefer_position\n  // combine the two\n  return (a_rating_length + a_position_length) - (b_rating_length + b_position_length)\n\n}","/**\n * Sort array of objects - by property value in each object\n * @param arr {Array.<Object>} - array of objects\n * @param prop1_key {object} - property key name to sort by - each object in array must contain this\n * @param prop1_asc {boolean} - by default, will sort prop1 DESC, but if this is true, will sort ASC\n * @return {Array.<Object>} - array of objects, sorted\n */\nexport default function asort_objects_by_property(arr, prop1_key, prop1_asc = false) {\n  return arr.sort(asort_objects_by_property__helper.bind({ arr, prop1_key, prop1_asc }));\n};\n\n// helper function:\nfunction asort_objects_by_property__helper(a, b) {\n  // sort by rating\n  let a_rating = a[this.prop1_key];\n  let b_rating = b[this.prop1_key];\n  // sort order\n  if (this.prop1_asc) {\n    // prefer lower number\n    // if b is lower, then rate it better than a\n    return a_rating - b_rating;\n  } else {\n    // prefer higher number\n    // if b is higher, then rate it better than a\n    return b_rating - a_rating;\n  }\n}\n\n","/**\n * Sort array of strings by separate dictionary of [{string:rating},], and\n * also by position in array. Items at front of array will be rated higher.\n * @param arr {Array.<String>} - array of strings\n * @param rating_key {string} - which property of object to use as sort rating (must be a number)\n * @param multiply_position {number} - make position x times more important than rating\n * @return {Array.<String>} - array of strings\n */\nexport default function (arr, rating_key, multiply_position = 1) {\n  let that = {}\n\n  // rating_key\n  that.min_rating = null\n  that.max_rating = null\n  that.rating_key = rating_key\n  for (let obj of arr) {\n    let rate = obj[rating_key]\n    // compare ratings to each other\n    if (that.min_rating === null || rate < that.min_rating) {\n      that.min_rating = rate\n    }\n    if (that.max_rating === null || rate > that.max_rating) {\n      that.max_rating = rate\n    }\n  }\n  that.delta_rating = that.max_rating - that.min_rating\n  that.median_rating = that.min_rating + (that.delta_rating/2)\n\n  // prepare position\n  that.min_index = 0\n  that.max_index = arr.length - 1\n  for (let i in arr) {\n    // count up - first item = 0, last item = (length-1)\n    arr[i].index = i\n  }\n  that.delta_index = that.max_index - that.min_index\n  that.multiply_position = multiply_position\n\n  // sort\n  return arr.sort(asort_strings_by_rating_and_position__helper.bind(that))\n};\n\n// helper function:\nfunction asort_strings_by_rating_and_position__helper(a, b) {\n\n  // higher == better\n  // normalized to 0-1 range\n  // highest rating gets 1, lowest rating gets 0\n  let a_rating = (this.delta_rating - (this.max_rating - (typeof a[this.rating_key]!=='undefined' ? a[this.rating_key] : this.median_rating))) / this.delta_rating\n  let b_rating = (this.delta_rating - (this.max_rating - (typeof b[this.rating_key]!=='undefined' ? b[this.rating_key] : this.median_rating))) / this.delta_rating\n\n  // higher == better\n  // normalized to 0-1 range\n  // lowest index gets 1, highest index gets 0\n  // (multiply_position to make position score more important than rating score)\n  let a_index = ((this.max_index - a.index) / this.delta_index) * this.multiply_position\n  let b_index = ((this.max_index - b.index) / this.delta_index) * this.multiply_position\n\n  // combine the two\n  // if b is higher, then sort it closer to front of array compared to a\n  return (b_rating + b_index) - (a_rating + a_index)\n}\n","/**\n * Mix multiple lists of strings into one list, by taking one item from each\n *    Takes unlimited number of arguments, but each must be an array!\n * @params strs1 {array} - array of strings\n * @params strs2 {array} - array of strings\n * @params strs3 {array} - array of strings\n * @returns {array} - new array (immutable), aggregated\n */\nexport const arr_mix = function (arrays) {\n  let master_list = []\n  // find length of longest array\n  let max_length = 0\n  for (let arr of arrays) {\n    max_length = Math.max(arr.length, max_length)\n  }\n\n  // iterate by index\n  // check item at each index in each array\n  let index = 0\n  while (true) {\n    // add one item from each array\n    for (let arr of arrays) {\n      if (arr[index]) {\n        // add item if exists\n        master_list.push(arr[index])\n      }\n    }\n\n    // next index\n    index++\n    if (index >= max_length) {\n      break\n    }\n  }\n  return master_list\n}\n\n/**\n * arr.length alternative\n *      actually useful, because it checks for existence of ${arr}\n * @param arr {array}\n * @returns {number}\n */\nexport const arr_length = function (arr) {\n  return arr && arr.length ? arr.length : 0\n}\n\n/**\n * Create an array\n */\nexport const arr_from_value = function (value, len) {\n  let arr = []\n  for (let i = 0; i < len; i++) {\n    arr.push(value)\n  }\n  return arr\n}\n\n/**\n * Subtract array B values from array A. Return remaining array A.\n *      NOTE: first array A must be the main one. Words also appearing in B will be removed\n * @param a {array}\n * @param b {array} - for comparison only. Array values unique to B will be ignored\n * @returns {array} - returns an array of values which appear in A but not B\n */\nexport const arr_diff = function (a, b) {\n  // a: source/destination array\n  // b: compare to this\n  return a.filter(function (i) {\n    return !b.includes(i)\n  })\n}\n\n/**\n * Remove an item (if exact match string/number) from array\n */\nexport const arr_remove_item = function (arr=[], item='') {\n  return arr.filter(it=>it!==item)\n}\n\n/**\n * Similarities between arrays A and B\n * @param a {array}\n * @param b {array}\n * @returns {array} - returns an array with values which appear in both A and B\n */\nexport const arr_includes = function (a, b) {\n  return a.filter(function (i) {\n    return b.includes(i)\n  })\n}\n\n/**\n * Array with empty/falsy values removed.\n * @param arr {array}\n * @returns {array}\n */\nexport const arr_truthy_values = function (arr) {\n  return arr.filter((val) => !!val)\n}\n","/** @module common-universal-scripts//functions/asort_words */\n\n/**\n * Sort input array by number of characters in string (or number cast to string)\n * Will sort ASC by default. Pass second parameter to sort by DESC.\n * @param {array} arr - expects array of strings,\n *       but will also accept array of anything,\n *       will cast any child to string `arr[i].toString()`\n * @param {boolean} desc - sort descending?\n *       if false or undefined, will be sorted ascending\n * @returns {array} arr - also modifies original array to returned value!\n */\nexport const asort_by_length = function (arr, desc = false) {\n\tlet sort_func = help_sort_by_length.bind({desc});\n\treturn arr.sort(sort_func);\n};\n/**\n * Sort input array NOT JUST by number of characters in string (like asort_by_length),\n * but instead, sort by width of the \"word\".\n *       Words with many short letters (\"i\" and \"l\") will be treated as having fewer characters.\n *       Especially nice glyphs like \"ll\" or \"li\" will be preferred.\n *       Words with wide letters or awkward glyphs (\"w\" or \"sch\") will be given lower position.\n * @param {array} arr - expects array of strings,\n *       but will also accept array of anything,\n *       will cast any child to string `arr[i].toString()`\n * @param {boolean} desc - sort descending?\n *       if false or undefined, will be sorted ascending\n * @returns {array} arr - also modifies original array to returned value!\n */\nexport const asort_by_width = function (arr, desc = false) {\n\tlet sort_func = help_sort_by_width.bind({desc});\n\treturn arr.sort(sort_func);\n};\n\n/*\n ***************************************************************************************\n * HELPER FUNCTIONS\n ***************************************************************************************\n */\n\n/**\n * Usage: `[].sort(help_sort_by_length)`\n * Note: NOT EXPORTED\n */\nfunction help_sort_by_length(a, b) {\n\tlet desc = this.desc;\n\tif (desc) {\n\t\treturn b.toString().length - a.toString().length;\n\t}\n\treturn a.toString().length - b.toString().length;\n}\n\n/**\n * Usage: `[].sort(help_sort_by_width)`\n *      String \"width\" is like \"\".length, but accounts for width of each character.\n *      It is not a JavaScript prototype, but is custom made from character map.\n * Note: NOT EXPORTED\n */\nfunction help_sort_by_width(a, b) {\n\tlet desc = this.desc;\n\tlet a_width = str_width(JSON.stringify(a || ''));\n\tlet b_width = str_width(JSON.stringify(b || ''));\n\tif (desc) {\n\t\treturn b_width - a_width;\n\t}\n\treturn a_width - b_width;\n}\n\n/**\n * Get pixel width of characters in word\n * param {string|number|array} str\n *      works best with {string}, but will convert an array or number .toString()\n * returns {number} width - like ''.length, but accounts for width of each character\n */\nfunction str_width(str) {\n\tstr = (str || '').toString(); // cast to string\n\tlet width = 0;\n\tfor (let char of str) {\n\t\twidth += char_width_plus[char.toLowerCase()] || 15; // default to high number if not English character\n\t}\n\treturn width;\n}\n\n/*\n ***************************************************************************************\n * HELPER VARIABLES\n ***************************************************************************************\n */\n\nconst glyph_width_plus = {};\nconst char_width_plus = {\n\t'0': 7,\n\t'1': 4,\n\t'2': 6,\n\t'3': 7,\n\t'4': 7,\n\t'5': 7,\n\t'6': 7,\n\t'7': 6,\n\t'8': 7,\n\t'9': 7,\n\t'a': 6,\n\t'b': 7,\n\t'c': 6,\n\t'd': 7,\n\t'e': 6,\n\t'f': 2,\n\t'g': 6,\n\t'h': 6,\n\t'i': 3,\n\t'j': 2,\n\t'k': 5,\n\t'l': 3,\n\t'm': 9,\n\t'n': 6,\n\t'o': 6,\n\t'p': 6,\n\t'q': 6,\n\t'r': 3,\n\t's': 5,\n\t't': 3,\n\t'u': 6,\n\t'v': 5,\n\t'w': 9,\n\t'x': 5,\n\t'y': 5,\n\t'z': 5,\n};\n","/**\n * Flatten a matrix of strings -\n *    - generate list of all unique possible cases, from matrix of strings\n * @params matrix {array} - array of arrays of strings, in a matrix format\n * @returns {array} - array of arrays of strings -\n *    - no longer a matrix, but just lists of phrases (phrase = array of strings)\n */\n// export const matrix_flatten_to_arrays = function (matrix) {\n//   if (matrix.length === 1) {\n//     return matrix[0]\n//   } else {\n//     let result = []\n//     let allCasesOfRest = matrix_flatten_to_arrays(matrix.slice(1)) // recur with the rest of matrixay\n//     for (let i = 0; i < allCasesOfRest.length; i++) {\n//       for (let j = 0; j < matrix[0].length; j++) {\n//         result.push(matrix[0][j] + allCasesOfRest[i])\n//       }\n//     }\n//     return result\n//   }\n// }\n/**\n * Flatten a matrix of strings -\n *    - generate list of all unique possible cases, from matrix of strings\n * @params matrix {array} - array of arrays of strings, in a matrix format\n * @returns {array} - array of combined strings, separated by space\n */\nexport const matrix_flatten_to_strings = function (matrix) {\n  if (!matrix.length) {\n    return []\n  } else if (matrix.length === 1) {\n    return matrix[0]\n  } else {\n    let result = []\n    let allCasesOfRest = matrix_flatten_to_strings(matrix.slice(1)) // recur with the rest of matrixay\n    for (let i = 0; i < allCasesOfRest.length; i++) {\n      for (let j = 0; j < matrix[0].length; j++) {\n        result.push(matrix[0][j] + \" \" + allCasesOfRest[i])\n      }\n    }\n    return result\n  }\n}\n\n/**\n * Shuffle some strings\n *    do not allow two strings to repeat which have the same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const astrings_shuffle_last_strict = function (strs) {\n  let output = []\n  let prev_ll = \"\" // last letter\n  let prev_strs_length = 0\n\n  // while loop as long as it takes! (should only be for a few milliseconds)\n  while (true) {\n    // prevent infinite loop - if strs arr length has not been changed,\n    // then we've reached a stalemate - no new items will be used\n    if (strs.length === prev_strs_length) {\n      break\n    } else {\n      prev_strs_length = strs.length\n    }\n    // each while loop, we'll take items out of the strs arr\n    for (let i = 0; i < strs.length; i++) {\n      // examine current item\n      let str = strs[i]\n      let ll = str[str.length - 1]\n      // if current string starts with different letter than previous string,\n      // add it to output. Else, ignore it, to examine it again next iteration\n      if (prev_ll !== ll) {\n        // add current item to output arr\n        output.push(str)\n        prev_ll = ll\n        // remove current item from input arr\n        strs.splice(i, 1)\n        i--\n      }\n    }\n  }\n\n  return [...new Set([...output, ...strs])]\n}\n\n/**\n * Shuffle some strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const astrings_shuffle_first_last_strict = function (strs) {\n  let output = []\n  let prev_fl = \"\" // first letter\n  let prev_ll = \"\" // last letter\n  let prev_strs_length = 0\n\n  // while loop as long as it takes! (should only be for a few milliseconds)\n  while (true) {\n    // prevent infinite loop - if strs arr length has not been changed,\n    // then we've reached a stalemate - no new items will be used\n    if (strs.length === prev_strs_length) {\n      break\n    } else {\n      prev_strs_length = strs.length\n    }\n    // each while loop, we'll take items out of the strs arr\n    for (let i = 0; i < strs.length; i++) {\n      // examine current item\n      let str = strs[i]\n      let fl = str[0]\n      let ll = str[str.length - 1]\n      // if current string starts with different letter than previous string,\n      // add it to output. Else, ignore it, to examine it again next iteration\n      if (prev_ll !== ll && prev_fl !== fl) {\n        // add current item to output arr\n        output.push(str)\n        prev_fl = fl\n        prev_ll = ll\n        // remove current item from input arr\n        strs.splice(i, 1)\n        i--\n      }\n    }\n  }\n\n  return [...new Set([...output, ...strs])]\n}\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const astrings_shuffle_last = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_ll = unique_str[unique_str.length - 1] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_ll = str[str.length - 1]\n        if (str_ll === unique_str_ll && str_ll === unique_str2_ll) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_ll = str[str.length - 1]\n      if (str_ll === unique_str_ll && str_ll === unique_str2_ll) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const astrings_shuffle_first_last = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_fl = unique_str[0] || \"\"\n    let unique_str_ll = unique_str[unique_str.length - 1] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_fl = unique_str2[0] || \"\"\n    let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_fl = str[0]\n        let str_ll = str[str.length - 1]\n        if (\n          (str_fl === unique_str_fl && str_fl === unique_str2_fl) ||\n          (str_ll === unique_str_ll && str_ll === unique_str2_ll)\n        ) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_fl = str[0]\n      let str_ll = str[str.length - 1]\n      if (\n        (str_fl === unique_str_fl && str_fl === unique_str2_fl) ||\n        (str_ll === unique_str_ll && str_ll === unique_str2_ll)\n      ) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n/**\n * Shuffle some strings\n *    do not allow two strings to repeat which have the same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const astrings_shuffle_last3_strict = function (strs) {\n  let output = []\n  let prev_ll = \"\" // last letter\n  let prev_strs_length = 0\n\n  // while loop as long as it takes! (should only be for a few milliseconds)\n  while (true) {\n    // prevent infinite loop - if strs arr length has not been changed,\n    // then we've reached a stalemate - no new items will be used\n    if (strs.length === prev_strs_length) {\n      break\n    } else {\n      prev_strs_length = strs.length\n    }\n    // each while loop, we'll take items out of the strs arr\n    for (let i = 0; i < strs.length; i++) {\n      // examine current item\n      let str = strs[i]\n      let ll = str[str.length - 3] + str[str.length - 2] + str[str.length - 1]\n      // if current string starts with different letter than previous string,\n      // add it to output. Else, ignore it, to examine it again next iteration\n      if (prev_ll !== ll) {\n        // add current item to output arr\n        output.push(str)\n        prev_ll = ll\n        // remove current item from input arr\n        strs.splice(i, 1)\n        i--\n      }\n    }\n  }\n\n  return [...new Set([...output, ...strs])]\n}\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const astrings_shuffle_first_last_loose = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_fl = unique_str[0] || \"\"\n    let unique_str_ll = unique_str[unique_str.length - 1] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_fl = unique_str2[0] || \"\"\n    let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\"\n\n    let unique_str3 = unique_strs[unique_strs.length - 3] || \"\" // 2nd to last added\n    let unique_str3_fl = unique_str3[0] || \"\"\n    let unique_str3_ll = unique_str3[unique_str3.length - 1] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_fl = str[0]\n        let str_ll = str[str.length - 1]\n        if (\n          (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) ||\n          (str_ll === unique_str_ll && str_ll === unique_str2_ll && str_ll === unique_str3_ll)\n        ) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_fl = str[0]\n      let str_ll = str[str.length - 1]\n      if (\n        (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) ||\n        (str_ll === unique_str_ll && str_ll === unique_str2_ll && str_ll === unique_str3_ll)\n      ) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n\n/**\n * Shuffle list of strings\n *    do not allow two strings to repeat which have the same first letter or same last letter\n * @params strs {array} - array of strings\n * @returns {array} - new array (immutable), of shuffled strs\n */\nexport const astrings_shuffle_last3 = function (input_strs = []) {\n  let memory_strs = []\n  let unique_strs = []\n\n  // console.time(\"1000 loops\")\n  let loops = 0\n  let old_strs = \"\"\n  infinite_loop: while (loops < 1000) {\n    loops++\n\n    // don't waste time on the same value\n    let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n    if (new_strs === old_strs) {\n      break infinite_loop\n    }\n    old_strs = new_strs\n\n    // no more inputs\n    if (!input_strs.length && !memory_strs.length) {\n      break infinite_loop\n    }\n\n    // first time\n    if (!unique_strs.length) {\n      unique_strs.push(input_strs.shift())\n      continue infinite_loop\n    }\n\n    // last added string\n    let unique_str = unique_strs[unique_strs.length - 1] || \"\" // last added\n    let unique_str_ll = unique_str[unique_str.length - 1] || \"\"\n\n    let unique_str2 = unique_strs[unique_strs.length - 2] || \"\" // 2nd to last added\n    let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\"\n\n    // insert new str\n    // from memory\n    if (memory_strs.length) {\n      for (let str of memory_strs) {\n        if (!str) continue\n        let str_ll = str[str.length - 1]\n        if (str_ll === unique_str_ll && str_ll === unique_str2_ll) {\n          // not unique\n          continue\n        } else {\n          // add unique\n          unique_strs.push(memory_strs.shift())\n          continue infinite_loop\n        }\n      }\n    }\n\n    // insert new str\n    // from input\n    if (input_strs[0]) {\n      let str = input_strs.shift()\n      let str_ll = str[str.length - 1]\n      if (str_ll === unique_str_ll && str_ll === unique_str2_ll) {\n        // not unique\n        memory_strs.push(str)\n      } else {\n        // add unique\n        unique_strs.push(str)\n      }\n    }\n  }\n  // console.timeEnd(\"1000 loops\")\n\n  return [...unique_strs, ...memory_strs, ...input_strs]\n}\n\n\n\n//\n// export const astrings_shuffle = function(input_strs, {first=false, last=false, repeat=3, chars=1}) {\n//\n//   let memory_strs = []\n//   let unique_strs = []\n//\n//   // console.time(\"1000 loops\")\n//   let loops = 0\n//   let old_strs = \"\"\n//   infinite_loop: while (loops < 1000) {\n//     loops++\n//\n//     // don't waste time on the same value\n//     let new_strs = input_strs[0] + memory_strs[0] + unique_strs[0]\n//     if (new_strs === old_strs) {\n//       break infinite_loop\n//     }\n//     old_strs = new_strs\n//\n//     // no more inputs\n//     if (!input_strs.length && !memory_strs.length) {\n//       break infinite_loop\n//     }\n//\n//     // first time\n//     if (!unique_strs.length) {\n//       unique_strs.push(input_strs.shift())\n//       continue infinite_loop\n//     }\n//\n//     // last string\n//     let unique_str = unique_strs[unique_strs.length - 1] || \"\"\n//     let unique_str_fl = unique_str[0] || \"\"\n//     let unique_str_ll = unique_str[unique_str.length - 1] || \"\" // last character\n//     // 2nd last string\n//     let unique_str2 = unique_strs[unique_strs.length - 2] || \"\"\n//     let unique_str2_fl = unique_str2[0] || \"\"\n//     let unique_str2_ll = unique_str2[unique_str2.length - 1] || \"\" // last character\n//     // 3rd last string\n//     let unique_str3 = unique_strs[unique_strs.length - 3] || \"\"\n//     let unique_str3_fl = unique_str3[0] || \"\"\n//     let unique_str3_ll = unique_str3[unique_str3.length - 1] || \"\" // last character\n//\n//     // insert new str\n//     // from memory\n//     if (memory_strs.length) {\n//       for (let str of memory_strs) {\n//         if (!str) continue\n//         let str_fl = str[0]\n//         let str_ll = str[str.length - 1]\n//         if (\n//           (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) ||\n//           (str_ll === unique_str_ll && str_ll === unique_str2_ll && str_ll === unique_str3_ll)\n//         ) {\n//           // not unique\n//           continue\n//         } else {\n//           // add unique\n//           unique_strs.push(memory_strs.shift())\n//           continue infinite_loop\n//         }\n//       }\n//     }\n//\n//     // insert new str\n//     // from input\n//     labeled_if:\n//     if (input_strs[0]) {\n//       let str = input_strs.shift()\n//       let str_fl = str[0]\n//       let str_ll = str[str.length - 1]\n//       if (\n//         (str_fl === unique_str_fl && str_fl === unique_str2_fl && str_fl === unique_str3_fl) ||\n//         (str_ll === unique_str_ll && str_ll === unique_str2_ll && str_ll === unique_str3_ll)\n//       ) {\n//         // not unique\n//         memory_strs.push(str)\n//       } else {\n//         // add unique\n//         unique_strs.push(str)\n//       }\n//     }\n//   }\n//\n//   return [...unique_strs, ...memory_strs, ...input_strs]\n// }","/*\n PARSE CLI ARGS\n\n Example: `node myScript.js -f1 --flag2 var1=whatever`\n args = {\n  __node__: '/usr/local/bin/node',\n  __file__: '~/my/path/myScript.js',\n  -f1: undefined,\n  --flag2: undefined,\n  var1: 'whatever',\n }\n Use args.hasOwnProperty('--flag2') to check for usage of\n flags which have no value.\n\n NOTE:\n Too keep things simple, limit arguments to the format shown\n in example above.\n This particular parser is not compatible with args values\n which come after a space ' ' instead of an '=' equal symbol.\n\n */\nexport function parse_cli_args() {\n  // BROWSER JS (front-end) DOES NOT HAVE CLI ARGUMENTS\n  if (typeof process === \"undefined\") {\n    return {}\n  }\n  // NODE JS (back-end)\n  let args = {}\n  for (let j = 0; j < process.argv.length; j++) {\n    let argv = process.argv[j]\n    if (j === 0) {\n      // first arg is node path\n      args[\"__node__\"] = argv\n    } else if (j === 1) {\n      // first arg is script path\n      args[\"__file__\"] = argv\n    } else {\n      // read each CLI argument as {key:value}\n      let arr = argv.split(\"=\")\n      // if no value (arr[1] is undefined), that's ok\n      args[arr[0]] = arr[1]\n    }\n  }\n  return args\n}\n","/**\n * Anonymous function wrapper - more reliable than ;(()=>{ ... })()\n *    Probem is anonymous function sometimes fails silently, even in try/catch !\n *    This try/catch implementation is more reliable.\n *    Also, don't need leading semicolon, if you're into not using semicolons.\n * @param tryCode\n * @param catchAction\n */\nexport const anonFunction = (tryCode, catchAction) => {\n  try {\n    // hopefully it works:\n    tryCode()\n  } catch (err) {\n    // something broke!\n    cconsole ? cconsole.error(err) : console.error(err)\n    // stop and inspect\n    if (catchAction === \"exit\" && typeof process !== \"undefined\") {\n      // exit\n      process.exit()\n    } else {\n      // debug\n      debugger\n    }\n  }\n}\n","export const average = function (values) {\n\tlet sum = values.reduce((previous, current) => current += previous);\n\treturn sum / values.length;\n};\n\nexport const mean = function (values) {\n\tvalues.sort((a, b) => a - b);\n\tlet lowMiddle = Math.floor((values.length - 1) / 2);\n\tlet highMiddle = Math.ceil((values.length - 1) / 2);\n\treturn (values[lowMiddle] + values[highMiddle]) / 2;\n};\n\nexport const is_number = function (variable) {\n\tif (variable === null) {\n\t\treturn false;\n\t}\n\tif (typeof variable === 'string') {\n\t\tvariable = Number(variable);\n\t}\n\tif (isNaN(variable)) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n","/**\n * @param {object} obj1\n * @param {object} obj2\n * @returns {boolean} - true if equal\n */\nexport const obj_is_equal = function obj_is_equal(obj1, obj2) {\n  return JSON.stringify(obj1) === JSON.stringify(obj2)\n}\n\n/**\n * @param {array} arr\n * @returns {object}\n */\nexport const obj_from_array = function obj_from_array(arr, default_value=true) {\n  let obj = {}\n  for (let key of arr) {\n    obj[key] = default_value\n  }\n  return obj\n}\n\n/**\n * @param {object} obj\n * @returns value of first item in object\n */\nexport const obj_first_value = function obj_first_value(obj) {\n  for (let key in obj) {\n    let val = obj[key]\n    return val\n    break // idk, just in case\n  }\n}\n\n/**\n * @param {object} obj\n * @returns {boolean} - true if empty\n */\nexport const obj_is_empty = function obj_is_empty(obj) {\n  for (let prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Parse JSON variable - recursively\n * @param {*} value - Any variable type\n * @returns {*} value - Intelligently parsed. Note: Will convert stringified number to type number!\n * NOTE: JSON can not stringify ES6 types Set and Map. Stringify/parse, changes value to empty object.\n * As a workaround, before stringifying, convert Set to Array, and Map to Array of tuples.\n */\nexport const json_parse = function json_parse(value) {\n  let variable\n  // Simple parse variable\n  if (typeof value === \"string\" && (value.includes(\"[\") || value.includes(\"{\"))) {\n    try {\n      variable = JSON.parse(value) // JSON stringified array or object\n    } catch (e) {\n      try {\n        variable = JSON.parse(value.replace(/[\\r\\n]+/g, \"\").replace(/[\\t]+/g, \" \")) // edge case\n      } catch (e) {\n        variable = value.includes(\"[\") ? [] : {} // broken JSON array or object\n      }\n    }\n  } else if (value === \"true\" || value === \"false\" || \"null\" || \"undefined\") {\n    // boolean/null should NOT have been stringified\n    variable = value // string\n  } else {\n    // simple value (JSON.parse converts numbers in quotes to type number)\n    try {\n      variable = JSON.parse(value) // number\n    } catch (e) {\n      variable = value // string or undefined\n    }\n  }\n  // Parse recursively - if Object/Array\n  if (typeof variable === \"object\") {\n    // iterate all props/values\n    for (let key in variable) {\n      if (!variable.hasOwnProperty(key)) continue\n      // parse each prop/value\n      variable[key] = json_parse(variable[key])\n    }\n  }\n\n  return variable\n}\n\n/**\n * Merge key/values of two objects into one - recursively\n * @param {object} obj1 - First object, the default one\n * @param {object} obj2 - Second object, will overwrite first!\n * @returns {object} obj - Combined object\n */\nexport const obj_merge = function obj_merge(obj1, obj2) {\n  // console.log('obj1', JSON.parse(JSON.stringify(obj1)));\n  // console.log('obj2', JSON.parse(JSON.stringify(obj2)));\n  let obj = {}\n  // get keys from both objects\n  let keys = [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])]\n  for (let key of keys) {\n    // both assigned ? then merge\n    if (obj1.hasOwnProperty(key) && obj2.hasOwnProperty(key)) {\n      let obj1v = obj1[key]\n      let obj2v = obj2[key]\n      // if both objects have same key, then merge\n      if (typeof obj1v !== typeof obj2v) {\n        // oh no! same key, but value is different type!\n        obj[key] = obj2v || obj1v\n        // console.warn('obj_merge(obj1, obj2) could not merge types: key/value type of each must be same: ', typeof obj1v, typeof obj2v);\n      } else {\n        // same type of value - lets try to combine...\n        switch (typeof obj1v) {\n          case \"object\":\n            // type = object\n            if (!!obj2v && !!obj1v) {\n              // both are truthy...\n              if (Array.isArray(obj2v) && Array.isArray(obj1v)) {\n                // both arrays...\n                obj[key] = [...new Set([...obj1[key], ...obj2[key]])]\n              } else if (!Array.isArray(obj2v) && !Array.isArray(obj1v)) {\n                // both dictionaries...\n                obj[key] = obj_merge(obj1[key], obj2[key])\n              } else {\n                // one is dictionary, other is array.\n                // cannot combine unlike types. Use first...\n                obj[key] = obj1[key]\n              }\n            } else {\n              // at least one is null...\n              obj[key] = obj2v || obj1v\n            }\n            break\n          default:\n            // type = undefined, function, boolean, string, number\n            obj[key] = obj2v || obj1v\n            break\n        }\n      }\n    } else if (obj2.hasOwnProperty(key)) {\n      // otherwise, use whichever one has a value\n      obj[key] = obj2[key]\n    } else {\n      // otherwise, use whichever one has a value\n      obj[key] = obj1[key]\n    }\n  }\n  // console.log('obj', obj);\n  return obj\n}\n","export const sleep = function(ms = 0) {\n  return new Promise(r => setTimeout(r, ms))\n}\n\nexport const forEachAsync = async function(array, fn) {\n  for (let t of array) {\n    await fn(t)\n  }\n}\n","/**\n * Parse and combine POST data and URL params into JavaScript object\n * @param req {object} - IMPORTANT: does not have to be real api request. Can be simple object.\n * @param req.body {object} - key/value pairs, already parsed and ready to use\n * @param req.query {object} - object of key/value pairs from URL query string\n *    This function will decodeURIComponent then parse each value.\n *    These req.query values will override values from req.body!\n * @returns {{}} - combined keys/values. Original request object will NOT be modified.\n */\nexport const aggregate_req_body_query = function (req) {\n  let query = {}\n  // body (POST data)\n  if (req.body) {\n    query = req.body\n  }\n  // query (URL parameters)\n  if (req.query) {\n    for (let key in req.query) {\n      let val = req.query[key]\n      if (val === 0) {\n        query[key] = 0\n        continue\n      }\n      if (!val) continue\n      val = decodeURIComponent(val).trim()\n      if (!val) continue\n      if (val === \"undefined\") {\n        query[key] = \"undefined\"\n        continue\n      }\n      if (val === \"null\") {\n        query[key] = \"null\"\n        continue\n      }\n      if (val === \"true\") {\n        query[key] = true\n        continue\n      }\n      if (val === \"false\") {\n        query[key] = false\n        continue\n      }\n      if (['\"', \"{\", \"[\"].includes(val[0])) {\n        try {\n          val = JSON.parse(val)\n        } catch (e) {\n          val = \"\"\n        }\n      }\n      query[key] = val\n    }\n  }\n  // combined\n  return query\n}\n","export const str_hash = function (str) {\n  let hash = 0\n  if (str.length === 0) {\n    return hash\n  }\n  for (let i = 0; i < str.length; i++) {\n    let char = str.charCodeAt(i)\n    hash = (hash << 5) - hash + char\n    hash = hash & hash // Convert to 32bit integer\n  }\n  return hash+''\n}\n\nexport const str_capitalize = function (word) {\n  return word.charAt(0).toUpperCase() + word.slice(1)\n}\n\nexport const str_sanitize_loosely = function (word) {\n  return word\n    .replace(/_-/g, \" \")\n    .replace(/[^\\w ]+/g, \"\")\n    .toLowerCase()\n    .trim()\n}\nexport const str_sanitize_strictly = function (word) {\n  return word\n    .replace(/[^\\w]+/g, \"\")\n    .toLowerCase()\n    .trim()\n}\n\nexport const str_insert = function (string = \"\", index = 0, insert = \"\") {\n  return string.substring(0, index) + insert + string.substring(index, string.length)\n}\n\n/**\n * Trim a character other than whitespace\n * @param s {string} - string\n * @param c {string} - remove this character (or characters) from start/end\n * @returns {void | string}\n */\nexport const str_trim_char = function trim(s, c) {\n  if (c === \"]\") c = \"\\\\]\"\n  if (c === \"\\\\\") c = \"\\\\\\\\\"\n  return s.replace(new RegExp(\"^[\" + c + \"]+|[\" + c + \"]+$\", \"g\"), \"\")\n}\n\n/**\n * Trim all non-alphabetical (not a-zA-Z) characters\n * @param str {string} - string\n * @returns {string}\n */\nexport const str_trim_non_alpha = function trim(str) {\n  return str.replace(new RegExp(\"^[^a-z]+|[^a-z]+$\", \"gi\"), \"\")\n}\n\nexport const str_syllables_count = function str_syllables_count(word) {\n  word = word.toLowerCase() //word.downcase!\n  if (word.length <= 3) {\n    return 1\n  } //return 1 if word.length <= 3\n  word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, \"\") //word.sub!(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '')\n  word = word.replace(/^y/, \"\") //word.sub!(/^y/, '')\n  let match = word.match(/[aeiouy]{1,2}/g)\n  return match ? match.length : 0 //word.scan(/[aeiouy]{1,2}/).size\n}\n","import { str_trim_char } from \"./strings.js\"\n\n/**\n * Convert JavaScript Object to URL querystring\n * ex: \"?one=1&two=something\"\n */\nexport function querystring_from_object(params = {}) {\n  let qs = Object.keys(params)\n    .map((k) => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k]))\n    .join(\"&\")\n  if (qs) {\n    qs = \"?\" + qs\n  }\n  return qs\n}\n\n/**\n * Convert URL querystring to JavaScript Object\n * ex: \"?one=1&two=something\" => {one:1,two:'something'}\n */\nexport function object_from_querystring(str = \"\") {\n  // make object\n  let obj = {}\n  let pairs = str.replace(\"?\", \"\").split(\"&\")\n  for (let pair of pairs) {\n    if (!pair) continue\n    let tuple = pair.split(\"=\")\n    let key = tuple[0]\n    if (!key) continue\n    obj[key] = tuple[1] || \"\"\n  }\n  // decode value\n  for (let key in obj) {\n    obj[key] = decodeURIComponent(obj[key] || \"\").trim()\n  }\n  // done\n  return obj\n}\n\n/**\n * Change a url (GET) parameter in queryString string\n * @param queryString {string} - ex: \"?start=10&fruit=apple\"\n * @param key {string} - ex: \"fruit\"\n * @param value {string} - ex: \"species\"\n * @return {string} - ex: \"?start=10&species=apple\"\n */\nexport function queryStringReplaceKeyValue(queryString, key, value) {\n  // clean input\n  queryString = str_trim_char(queryString, \"&\")\n  queryString = str_trim_char(queryString, \"?\")\n  let obj = JSON.parse(\n    '{\"' + decodeURI(queryString).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/=/g, '\":\"') + '\"}'\n  )\n  // replace value\n  obj[key] = value\n  // rebuild queryString with replaced value\n  let output = \"?\"\n  for (let pair of Object.entries(obj)) {\n    output += pair[0] + \"=\"\n    output += pair[1] + \"&\"\n  }\n  return str_trim_char(output, \"&\")\n}\n","import { querystring_from_object } from \"./urls.js\"\n\n/**\n * Parse Axios error message\n * @param {string} source - external URL to load\n * @param {object} beforeEl - DOM element before which to insert the new <script> tag\n * @param {object} scriptAttrs - object of attributes to add to the new <script> tag\n */\nexport const load_script = function (source, beforeEl, scriptAttrs = {}) {\n  if (!source) return false\n  if (typeof window !== \"object\" || typeof document !== \"object\") return false\n  return new Promise((resolve, reject) => {\n    let script = document.createElement(\"script\")\n\n    // force certain attributes\n    script = { ...script, async: true, defer: true, ...scriptAttrs }\n\n    // NOTE: needs refactor: maybe .bind(script)\n    function onloadHander(_, isAbort) {\n      if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {\n        script.onload = null\n        script.onreadystatechange = null\n        script = undefined\n\n        if (isAbort) {\n          reject()\n        } else {\n          resolve()\n        }\n      }\n    }\n\n    script.onload = onloadHander\n    script.onreadystatechange = onloadHander\n\n    script.src = source\n    window.document.body.append(script)\n  })\n}\n\n/**\n * Parse Axios error message\n * @param {object} error - error can come in multiple formats, but always an object\n * @returns {string} - logs full error, but returns nice readable text for UI alert\n */\nexport const parse_axios_error = function (error) {\n  // parse data from AJAX:\n  let data = (error.response && error.response.data && error.response.data.error) || error\n  // which format is data?\n  if (typeof data === \"object\") {\n    // array or object\n    let message = data[0] || data.message\n    // log to console\n    if (typeof console !== \"undefined\") console.error(\"axios error\", message)\n    // return to app\n    return message\n  } else {\n    // string or unknown\n    let message = data\n    // log to console\n    if (typeof console !== \"undefined\") console.error(\"axios error\", message)\n    // return to app\n    return message\n  }\n}\n\n/**\n * GET request\n * @param {string} url\n * @param {object} data\n * @returns {Promise}\n */\nexport const api_get = function (url = ``, data = {}) {\n  // Auth\n  // url = url;\n  // Default options are marked with *\n  return fetch(url + querystring_from_object(data), {\n    method: \"GET\", // *GET, POST, PUT, DELETE, etc.\n    mode: \"cors\", // no-cors, cors, *same-origin\n    cache: \"no-cache\", // *default, no-cache, reload, force-cache, only-if-cached\n    credentials: \"same-origin\", // include, *same-origin, omit\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n      // \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    redirect: \"follow\", // manual, *follow, error\n    referrer: \"no-referrer\" // no-referrer, *client\n  })\n    .then((response) => response.json()) // parses response to JSON\n    .then((response) => response.data)\n}\n\n/**\n * POST request\n * @param {string} url\n * @param {object} data\n * @returns {Promise}\n */\nexport const api_post = function (url = ``, data = {}) {\n  // Auth\n  // url = url;\n  // Default options are marked with *\n  return fetch(url, {\n    method: \"POST\", // *GET, POST, PUT, DELETE, etc.\n    mode: \"cors\", // no-cors, cors, *same-origin\n    cache: \"no-cache\", // *default, no-cache, reload, force-cache, only-if-cached\n    credentials: \"same-origin\", // include, *same-origin, omit\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n      // \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    redirect: \"follow\", // manual, *follow, error\n    referrer: \"no-referrer\", // no-referrer, *client\n    body: JSON.stringify(data) // body data type must match \"Content-Type\" header\n  }).then((response) => response.json()) // parses response to JSON\n}\n\n/**\n * PUT request\n * @param {string} url\n * @param {object} data\n * @returns {Promise}\n */\nexport const api_put = function (url = ``, data = {}) {\n  // Auth\n  // url = url;\n  // Default options are marked with *\n  return fetch(url, {\n    method: \"PUT\", // *GET, POST, PUT, DELETE, etc.\n    mode: \"cors\", // no-cors, cors, *same-origin\n    cache: \"no-cache\", // *default, no-cache, reload, force-cache, only-if-cached\n    credentials: \"same-origin\", // include, *same-origin, omit\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n      // \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    redirect: \"follow\", // manual, *follow, error\n    referrer: \"no-referrer\", // no-referrer, *client\n    body: JSON.stringify(data) // body data type must match \"Content-Type\" header\n  }).then((response) => response.json()) // parses response to JSON\n}\n","export const log = function () {\n\tlet action = 'log';\n\tif (['log', 'info', 'warn', 'error', 'table', 'debug', 'trace'].includes(arguments[0])) {\n\t\taction = arguments.shift();\n\n\t}\n\tconsole[action](...arguments);\n};\n\nexport const js = function (val) {\n\treturn JSON.stringify(val);\n};\n\nexport const jsp = function (val) {\n\treturn JSON.parse(JSON.stringify(val));\n};\n\n\n// import PropTypes from 'prop-types';\n//\n// let propTypeShapeOf = function (value) {\n// \t// console.log('propTypeShapeOf', value);\n// \tlet output = 'PropTypes.shape({\\n';\n// \tfor (let key in value) {\n// \t\tconsole.log('that.' + key);\n// \t\t// output += `  ${key}: PropTypes.${propTypeOf(value[key])}.isRequired,\\n`;\n// \t}\n// \toutput += '}),';\n// \treturn output;\n// };\n// let propTypeOf = function (value) {\n// \tswitch (typeof value) {\n// \t\tcase 'function':\n// \t\t\treturn 'func';\n// \t\tcase 'boolean':\n// \t\t\treturn 'bool';\n// \t\tcase 'object':\n// \t\t\tif (Array.isArray(value)) {\n// \t\t\t\treturn 'array';\n// \t\t\t} else if (value === null) {\n// \t\t\t\treturn 'null';\n// \t\t\t} else {\n// \t\t\t\treturn propTypeShapeOf(value);\n// \t\t\t}\n// \t\t\treturn 'bool';\n// \t\tdefault:\n// \t\t\treturn typeof value;\n// \t}\n// };\n// DomainsResults.propTypes = {\n// \tthat: pt.shape({\n// \t\tstate: pt.shape({}),\n// \t\tprops: pt.shape({}),\n// \t\ttoggleResults: pt.func({}),\n// \t}),\n// };\n\n// /*\n//  * build propTypes declaration, recursively\n//  */\n// let pt = 'that: ' + propTypeShapeOf(that);\n// console.log(pt);","export const isRetina = function () {\n  // return boolean:\n  return typeof window === 'object'\n      ? window.matchMedia(\n        '(-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2), (min-resolution: 192dpi)',\n      ).matches\n      : false\n}","export const syllable_count = function syllable_count(str) {\n  if (!str) return 0\n  let original = str\n  str = str.replace(\"ue\", \"e\")\n  str = str.substr(0, str.length - 1)\n  str = str.replace(/[^aeiouy]+/g, \" \")\n  let words = str\n    .split(\" \")\n    .map((w) => w.trim())\n    .filter((w) => !!w)\n  let syllables = words.length\n  return syllables === 0 ? original.length : syllables\n}\nexport const is_vowel = function syllable_count(str) {\n  return [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"].includes(str)\n}\nexport const ends_in_vowel = function syllable_count(str) {\n  return [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"].includes(str[str.length-1])\n}\n","import asort_by_extension from \"./asort_strings/asort_by_extension.js\"\nimport asort_by_length_and_position from \"./asort_strings/asort_by_length_and_position.js\"\nimport asort_by_length_asc from \"./asort_strings/asort_by_length_asc.js\"\nimport asort_by_matches_in_list from \"./asort_strings/asort_by_matches_in_list.js\"\nimport asort_by_rating from \"./asort_strings/asort_by_rating.js\"\nimport asort_by_rating_and_position from \"./asort_strings/asort_by_rating_and_position.js\"\nimport asort_strings_combine_lists from \"./asort_strings/asort_strings_combine_lists.js\"\nimport asort_objects_by_property from \"./asort_objects/asort_by_property.js\"\nimport asort_objects_by_property_and_position from \"./asort_objects/asort_by_property_and_position.js\"\nimport * as arrays from \"./arrays.js\"\nimport * as asort_words from \"./asort_words.js\"\nimport * as astrings from \"./astrings.js\"\nimport * as cli from \"./cli.js\"\nimport * as functions from \"./functions.js\"\nimport * as numbers from \"./numbers.js\"\nimport * as objects from \"./objects.js\"\nimport * as promises from \"./promises.js\"\nimport * as req from \"./req.js\"\nimport * as requests from \"./requests.js\"\nimport * as sh from \"./sh.js\"\nimport * as strings from \"./strings.js\"\nimport * as ui from \"./ui.js\"\nimport * as urls from \"./urls.js\"\nimport * as words from \"./words.js\"\n\nwindow.uui = {\n  asort_objects_by_property,\n  asort_objects_by_property_and_position,\n  asort_by_extension,\n  asort_by_length_and_position,\n  asort_by_length_asc,\n  asort_by_matches_in_list,\n  asort_by_rating,\n  asort_by_rating_and_position,\n  asort_strings_combine_lists,\n  arrays,\n  asort_words,\n  astrings,\n  cli,\n  functions,\n  numbers,\n  objects,\n  promises,\n  req,\n  requests,\n  sh,\n  strings,\n  ui,\n  urls,\n  words\n}\n","/**\n * NOT [].sort(). Simply combines multiple arrays, one item from each array at a time.\n * Like taking two decks of cards, and making one double deck, by taking one card at a time from each deck.\n * But can be more than 2 arrays! Pass in as many as needed. Will take one item from each, at a time.\n * @param arr1 {Array.<String>} - array of strings\n * @param arr2 {Array.<String>} - array of strings\n * @return {Array.<String>} - array of strings, combined!\n */\nexport default function asort_strings_combine_lists(arr1, arr2) {\n  let list = new Set();\n\n  /*\n   * setup pointers (will be incremented each time new item is taken from array)\n   */\n  let ai = {};\n  for (let i in arguments) {\n    // will be incremented (ai[i]++) before each use\n    ai[i] = -1; // on first use will === 0\n  }\n\n  /*\n   * iterate all passed-in arrays, one by one, take one new item at a time\n   */\n  for (let y = 0; y < 50; y++) {\n    for (let i in arguments) {\n      let arr = arguments[i];\n      let str = arr[ai[i]++];\n      if (str) {\n        list.add(str)\n      }\n    }\n  }\n\n  // console.log('asort_strings_combine_lists list', list);\n  return [...list];\n  // return arr1;\n\n}\n\n"],"names":["asort_by_extension__helper","a","b","this","indexOf","substr","asort_by_length_asc","arr","desc","arguments","length","undefined","sort","toString","asort_by_matches_in_list__helper","a_score","asort_strings_by_rating__helper","a_rating","asort_strings_by_rating_and_position__helper","delta_rating","max_rating","ratings","median_rating","b_rating","a_index","max_index","indexes","delta_index","multiply_position","asort_by_length_and_position_asc__helper","a_length","b_length","fix_min_length","a_rating_length","min_length","delta_length","b_rating_length","arr_positions","min_position","delta_position","prefer_position","asort_objects_by_property__helper","prop1_key","prop1_asc","rating_key","index","arrays","_step","master_list","max_length","_iterator","$d626a46329868511b59debfe23cff3dd$var$_createForOfIteratorHelper","s","n","done","value","Math","max","err","e","f","_step2","_iterator2","push","len","i","filter","includes","item","it","val","sort_func","help_sort_by_length","bind","help_sort_by_width","a_width","str_width","JSON","stringify","b_width","str","width","$be0ececc4d8e7e5efa126633c1d31a5f$var$_createForOfIteratorHelper","char","char_width_plus","toLowerCase","0","1","2","3","4","5","6","7","8","9","c","d","g","h","j","k","l","m","o","p","q","r","t","u","v","w","x","y","z","matrix_flatten_to_strings","matrix","result","allCasesOfRest","slice","strs","output","prev_ll","prev_strs_length","ll","splice","$e4d0498aff0091bafac83ad17772cb7$var$_toConsumableArray","Set","concat","prev_fl","fl","input_strs","memory_strs","unique_strs","loops","old_strs","infinite_loop","new_strs","unique_str","unique_str_ll","unique_str2","unique_str2_ll","$e4d0498aff0091bafac83ad17772cb7$var$_createForOfIteratorHelper","str_ll","shift","unique_str_fl","unique_str2_fl","str_fl","unique_str3","unique_str3_fl","unique_str3_ll","_step3","_iterator3","_step4","_iterator4","process","args","argv","split","tryCode","catchAction","cconsole","error","console","exit","values","reduce","previous","current","lowMiddle","floor","highMiddle","ceil","variable","Number","isNaN","obj1","obj2","default_value","obj","$af1bc167776ce3d4b1c0631015d032$var$_createForOfIteratorHelper","key","prop","Object","prototype","hasOwnProperty","call","json_parse","parse","replace","$af1bc167776ce3d4b1c0631015d032$var$_typeof","obj_merge","$af1bc167776ce3d4b1c0631015d032$var$_toConsumableArray","keys","obj1v","obj2v","Array","isArray","ms","Promise","setTimeout","forEachAsync","_ref","$e57364e1e52149ed9c73861bec79$var$_asyncToGenerator","regeneratorRuntime","mark","_callee","array","fn","wrap","_context","prev","next","$e57364e1e52149ed9c73861bec79$var$_createForOfIteratorHelper","t0","finish","stop","_x","_x2","apply","req","query","body","decodeURIComponent","trim","hash","charCodeAt","word","charAt","toUpperCase","string","insert","substring","str_trim_char","RegExp","querystring_from_object","params","qs","map","encodeURIComponent","join","match","pairs","$eb1a366f1822d081e500b6784fc23ef4$var$_createForOfIteratorHelper","pair","tuple","queryString","$ed6a2c01c312378f8af85e459c$export$str_trim_char","decodeURI","_i","_Object$entries","entries","source","beforeEl","scriptAttrs","window","$d3242bd5d23d31e79c6b43254305$var$_typeof","document","resolve","reject","script","createElement","onloadHander","_","isAbort","readyState","test","onload","onreadystatechange","$d3242bd5d23d31e79c6b43254305$var$_objectSpread","async","defer","src","append","data","response","message","url","fetch","$eb1a366f1822d081e500b6784fc23ef4$export$querystring_from_object","method","mode","cache","credentials","headers","Content-Type","redirect","referrer","then","json","_console","action","$c78321ede8cf01e64fafcbba9bef$var$_typeof","matchMedia","matches","original","syllables","uui","asort_objects_by_property","asort_objects_by_property_and_position","that","$feefbcf9143df2dc8b6eb2ee5467e52$var$_createForOfIteratorHelper","rate","min_rating","min_index","asort_by_extension","endings","asort_by_length_and_position","ascending","$af595300c1e27adb208216724099ce82$export$default","$accc34deeb71a216d8eeb7f$var$_toConsumableArray","max_position","asort_by_matches_in_list","matchList","$a95e48a09f0c2361f1b3375f4f3$var$_createForOfIteratorHelper","count","asort_by_rating","preferences","$c3cc79afd6c5f1521521a8e4$var$_createForOfIteratorHelper","asort_by_rating_and_position","asort_strings_combine_lists","arr1","arr2","list","ai","add","$ffe311a18474863ea6f1a26b434fddf2$var$_toConsumableArray","$d626a46329868511b59debfe23cff3dd$exports","asort_words","$be0ececc4d8e7e5efa126633c1d31a5f$exports","astrings","$e4d0498aff0091bafac83ad17772cb7$exports","cli","$ddb3ca76f32cbb05bf421f38d6669b50$exports","functions","$ebd48dc7bee65e32fbdd11a9dc96d9$exports","numbers","$a64f17e5a6a384a5288396eddd50eb6f$exports","objects","$af1bc167776ce3d4b1c0631015d032$exports","promises","$e57364e1e52149ed9c73861bec79$exports","$b10f126b8250fb0a8cb5483f2ef505$exports","requests","$d3242bd5d23d31e79c6b43254305$exports","sh","$ad62e73689299c94269ea9609eef0d0d$exports","strings","$ed6a2c01c312378f8af85e459c$exports","ui","$c78321ede8cf01e64fafcbba9bef$exports","urls","$eb1a366f1822d081e500b6784fc23ef4$exports","words","$f46a6ab98b5cfa995dee7230ad3$exports"],"version":3,"file":"index.js.map"}